/*
 * 
 * ?????????+ +
 * ?????????? + +
 * ?????????? ?
 * ?????????? ++ + + +
 *  ????????? ?+
 * ?????????? +
 * ??????????
 * ?????????? + +
 * ??????????
 * ???????????????????
 * ???????? + + + +
 * ????????
 * ???????? +  ????
 * ????????    ???bug??
 * ??????????+?????????
 * ????? ??????? + +
 * ???? ?????????
 * ???? ?????????
 * ???????????? + + + +
 * ???????????
 * ???????????+ + + +
 * 
 * 
 * 
 * ************Copyright 2022 MCD************
 * 
 * @version      : 
 * @Company      : HOPE
 * @Author       : MCD
 * @Date         : 2022-08-17 12:53:59
 * @LastEditors  : MCD
 * @LastEditTime : 2022-08-17 12:56:31
 * @FilePath     : /My_C_Test/mcuQueue/qfifo.c
 * @Description  : 
 * 
 * ******************************************
 */

#include "qfifo.h"

//==============================================================================
//  ????
//==============================================================================
void Queue_Init(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * buffer, unsigned int len);
void Queue_Clear(QUEUE_HandleTypeDef * hqueue);
unsigned int Queue_Count(QUEUE_HandleTypeDef * hqueue);
QUEUE_StatusTypeDef Queue_Push(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T data);
unsigned int Queue_Push_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len);
QUEUE_StatusTypeDef Queue_Pop(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdata);
unsigned int Queue_Pop_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len);
QUEUE_StatusTypeDef Queue_Peek(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdata);
unsigned int Queue_Peek_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len);



//==============================================================================
//  ?????Queue_Init
//  ????????????????????????????????
//  ?????hqueue           ??????
//  ?????buffer           ???????
//  ?????len              ???????
//  ?????void
//==============================================================================
void Queue_Init(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * buffer, unsigned int len)
{
    hqueue->buffer = buffer;
    hqueue->buffer_length = len;
    Queue_Clear(hqueue);
}

//==============================================================================
//  ?????Queue_Clear
//  ?????????
//  ?????hqueue           ??????
//  ?????void
//==============================================================================
void Queue_Clear(QUEUE_HandleTypeDef * hqueue)
{
    hqueue->head = 0;
    hqueue->tail = 0;
}

//==============================================================================
//  ?????Queue_Count
//  ???????????????
//  ?????hqueue           ??????
//  ?????????????
//==============================================================================
unsigned int Queue_Count(QUEUE_HandleTypeDef * hqueue)
{
    if(hqueue->head <= hqueue->tail)
    {
        return (unsigned int)(hqueue->tail - hqueue->head);
    }
    else
    {
        return (unsigned int)(hqueue->buffer_length + hqueue->tail - hqueue->head);
    }
}

//==============================================================================
//  ?????Queue_Push
//  ?????????????
//  ?????hqueue           ??????
//  ?????data             ????????
//  ?????????
//==============================================================================
QUEUE_StatusTypeDef Queue_Push(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T data)
{
    unsigned int tmp = (hqueue->tail + 1) % hqueue->buffer_length;

    if(tmp == hqueue->head)
    {
        return QUEUE_OVERLOAD;
    }
    else
    {
        hqueue->buffer[hqueue->tail] = data;
        hqueue->tail = tmp;
        return QUEUE_OK;
    }
}

//==============================================================================
//  ?????Queue_Push_Array
//  ???????????????
//  ?????hqueue           ??????
//  ?????pdatas           ??????????
//  ?????len              ??????????
//  ????????????????
//==============================================================================
unsigned int Queue_Push_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len)
{
    unsigned int i;
    for(i=0; i<len; i++)
    {
        if(Queue_Push(hqueue,pdatas[i]) == QUEUE_OVERLOAD)
        {
            break;
        }
    }
    return i;
}


//==============================================================================
//  ?????Queue_Pop
//  ?????????????
//  ?????hqueue           ??????
//  ?????pdata            ????????????
//  ?????????
//==============================================================================
QUEUE_StatusTypeDef Queue_Pop(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdata)
{
    if(hqueue->head == hqueue->tail)
    {
        return QUEUE_VOID;
    }
    else
    {
        *pdata = hqueue->buffer[hqueue->head];
        hqueue->head = (hqueue->head + 1) % hqueue->buffer_length;
        return QUEUE_OK;
    }
}

//==============================================================================
//  ?????Queue_Pop_Array
//  ???????????????
//  ?????hqueue           ??????
//  ?????pdatas           ????????????
//  ?????len              ?????????????
//  ??????????????
//==============================================================================
unsigned int Queue_Pop_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len)
{
    unsigned int i;
    for(i=0; i<len; i++)
    {
        if(Queue_Pop(hqueue, &pdatas[i]) == QUEUE_VOID)
        {
            break;
        }
    }
    return i;
}


//==============================================================================
//  ?????Queue_Peek
//  ?????????????????????????
//  ?????hqueue           ??????
//  ?????pdata            ????????????
//  ?????????
//==============================================================================
QUEUE_StatusTypeDef Queue_Peek(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdata)
{
    if(hqueue->head == hqueue->tail)
    {
        return QUEUE_VOID;
    }
    else
    {
        *pdata = hqueue->buffer[hqueue->head];
        return QUEUE_OK;
    }
}

//==============================================================================
//  ?????Queue_Peek_Array
//  ??????????????????????????
//  ?????hqueue           ??????
//  ?????pdatas           ????????????
//  ?????len              ?????????????
//  ??????????????
//==============================================================================
unsigned int Queue_Peek_Array(QUEUE_HandleTypeDef * hqueue, QUEUE_DATA_T * pdatas, unsigned int len)
{
    unsigned int i;
    if(hqueue->head == hqueue->tail)
    {
        return 0;
    }
    if(Queue_Count(hqueue) < len)
    {
        len = Queue_Count(hqueue);
    }
    for(i=0; i<len; i++)
    {
        pdatas[i] = hqueue->buffer[(hqueue->head + i) % hqueue->buffer_length];
    }
    return len;
}




