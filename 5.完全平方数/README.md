完全平方数
===========================
题目内容介绍

****

| Author | 马陈东            |
| ------ | ------------------- |
| E-mail | machendong@nhope.cn |
|  From  | LEETCODE             |

****

# 描述
给定正整数 n，找到若干个完全平方数（比如 1, 4, 9, 16, ...）使得它们的和等于 n。你需要让组成和的完全平方数的个数最少。
```c
示例 1:

输入: n = 12
输出: 3 
解释: 12 = 4 + 4 + 4.

示例 2:

输入: n = 13
输出: 2
解释: 13 = 4 + 9.
```
1.第一种思路：四平方和定理：
四平方和定理——维基百科
Lagrange 四平方和定理
任何一个正整数都可以表示成不超过四个整数的平方之和。也就是说我们的返回值是[1,2,3,4]中的一个值。首先我们看两个得到导论：1.一个数如果含有因子4，我们可以将这个数除以4，用此所得数求并不影响结果，比如2和8或3和12等等，它们的结果相同；2.一个数除以8余7的话，则这个数由4个完全平方数组成。证明：满足此类的数由4个完全平方数组成
不能写成3个平方数之和的正整数
n＝(8k+7)4^m（k,m 为非负整数）不能表示为三个平方数之和
欧拉定理，费马小定理、Lagrange定理
```c
int numSquares(int n)
{
    while (n % 4 == 0)
        n /= 4;
    if (n % 8 == 7)
        return 4;
    if(n == 1)  return 1;
    for (int i = 0; i * i <= n; ++i)
    {
        // print_mcd("i = %d", i);
        int a = (int)sqrt(n - i * i);
        if (a * a + i * i == n)
        {
            if (a == 0)
                return 1;
            return 2;
        }
    }
    return 3;
}
```
2.复杂度分析：

时间复杂度：O(sqrt(n))。

空间复杂度：O(1)。

第二种思路：动态规划，首先我们就要找出动态转移方程，我不是大佬，只是个菜鸡，只能用笨方法找规律来总结动态转移方程，我们可以有两种思路：

    自顶向下：首先我们需要知道初始F(n) = n（n = 1 + 1 + 1 +......+ 1），题目中说n是由完全平方数组成的，那么n可以拆分一个完全平方数i^2与n-i^2两部分，然后可以得出n = i^2 + (n - i^2)（i的取值范围为[1, (int)sqrt(n)]），F(n) = min(n, 1 + F(n - i^2)) => min(1 + F(n - i^2), 1 + F(n - (i + 1)^2))，然后F(n - i^2)等等再分解，这样的话动态转移方程：F(n) =min(n, 1 + F(n - i^2)) => min(1 + F(n - i^2), 1 + F(n - (i + 1)^2))。
    
    自底向上：首先我们需要知道初始F(n) = n（n = 1 + 1 + 1 +......+ 1），F(0) = 0，F(1) = min(1, 1 + F(1 - 1^2)) = 1（1可以拆分成1^2 +(1 - 1^2)）, F(2) = min(2, 1 + F(2 - 1^2)) = 2（2可以拆分为1^2 + 2 - 1^2），F(3) = min(3, 1 + F(3 - 1^2)) = 3，F(4) = min(4, 1 + F(4 - 1^2)) = min(1 + F(4 - 1^2, 1 + F(4 - 2^2)) = 1，以此类推，得出状态转移方程为：F(n) =min(n, 1 + F(n - i^2)) => min(1 + F(n - i^2), 1 + F(n - (i + 1)^2))，i的取值范围为[1, (int)sqrt(n)]。
```c
int numSquares(int n)
{
    int dp[] = {0};
    
    for (int i = 0; i <=n; i++){
        dp[i] = i;
        int top = (int)sqrt(i);
        for (int j = 1; j <= top; j++){
            dp[i] = min(dp[i], dp[i - j * j] + 1);
        }
    }
    return dp[n];
}
```